(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define(factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/ 		
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/ 		
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 		
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 		
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/ 	
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/ 	
/******/ 	
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("\n/*\n  AngularJS wrapper for HubSpots's Tether\n */\nvar Tether, ngTetherDire, prefix,\n  __hasProp = {}.hasOwnProperty;\n\nTether = __webpack_require__(1);\n\nprefix = 'ngTether';\n\nngTetherDire = function() {\n  return {\n    restrict: 'A',\n    link: function(scope, element, attrs) {\n      var evaledOptions, key, optionKey, strippedKey, tetherHandle, tetherOptions, value;\n      tetherOptions = {};\n      for (key in attrs) {\n        if (!__hasProp.call(attrs, key)) continue;\n        value = attrs[key];\n        if (key !== prefix && (key.indexOf(prefix)) !== -1) {\n          strippedKey = key.replace(prefix, '');\n          optionKey = strippedKey[0].toLowerCase() + strippedKey.slice(1);\n          tetherOptions[optionKey] = value;\n        }\n      }\n      if (tetherOptions.options != null) {\n        evaledOptions = (scope.$eval(tetherOptions.options)) || {};\n        delete tetherOptions.options;\n        for (key in evaledOptions) {\n          if (!__hasProp.call(evaledOptions, key)) continue;\n          value = evaledOptions[key];\n          tetherOptions[key] = value;\n        }\n      }\n      if (tetherOptions.element == null) {\n        tetherOptions.element = element[0];\n      }\n      console.log(tetherOptions);\n      tetherHandle = new Tether(tetherOptions);\n      tetherHandle.position();\n      if (attrs[prefix] != null) {\n        return scope[attrs[prefix]] = tetherHandle;\n      }\n    }\n  };\n};\n\nmodule.exports = angular.module('ngTether', []).directive(prefix, ngTetherDire);\n\n\n// WEBPACK FOOTER\n// module.id = 0\n// module.readableIdentifier = ./ng-tether.coffee\n//@ sourceURL=webpack-module:///./ng-tether.coffee");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*! tether 0.6.5 */\n\n\n(function(root, factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_RESULT__ = __WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : module.exports = __WEBPACK_AMD_DEFINE_FACTORY__));\n  } else if (typeof exports === 'object') {\n    module.exports = factory(require,exports,module);\n  } else {\n    root.Tether = factory();\n  }\n}(this, function(require,exports,module) {\n\n(function() {\n  var Evented, addClass, defer, deferred, extend, flush, getBounds, getOffsetParent, getOrigin, getScrollBarSize, getScrollParent, hasClass, node, removeClass, uniqueId, updateClasses, zeroPosCache,\n    __hasProp = {}.hasOwnProperty,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },\n    __slice = [].slice;\n\n  if (this.Tether == null) {\n    this.Tether = {\n      modules: []\n    };\n  }\n\n  getScrollParent = function(el) {\n    var parent, position, scrollParent, style, _ref;\n    position = getComputedStyle(el).position;\n    if (position === 'fixed') {\n      return el;\n    }\n    scrollParent = void 0;\n    parent = el;\n    while (parent = parent.parentNode) {\n      try {\n        style = getComputedStyle(parent);\n      } catch (_error) {}\n      if (style == null) {\n        return parent;\n      }\n      if (/(auto|scroll)/.test(style['overflow'] + style['overflow-y'] + style['overflow-x'])) {\n        if (position !== 'absolute' || ((_ref = style['position']) === 'relative' || _ref === 'absolute' || _ref === 'fixed')) {\n          return parent;\n        }\n      }\n    }\n    return document.body;\n  };\n\n  uniqueId = (function() {\n    var id;\n    id = 0;\n    return function() {\n      return id++;\n    };\n  })();\n\n  zeroPosCache = {};\n\n  getOrigin = function(doc) {\n    var id, k, node, v, _ref;\n    node = doc._tetherZeroElement;\n    if (node == null) {\n      node = doc.createElement('div');\n      node.setAttribute('data-tether-id', uniqueId());\n      extend(node.style, {\n        top: 0,\n        left: 0,\n        position: 'absolute'\n      });\n      doc.body.appendChild(node);\n      doc._tetherZeroElement = node;\n    }\n    id = node.getAttribute('data-tether-id');\n    if (zeroPosCache[id] == null) {\n      zeroPosCache[id] = {};\n      _ref = node.getBoundingClientRect();\n      for (k in _ref) {\n        v = _ref[k];\n        zeroPosCache[id][k] = v;\n      }\n      defer(function() {\n        return zeroPosCache[id] = void 0;\n      });\n    }\n    return zeroPosCache[id];\n  };\n\n  node = null;\n\n  getBounds = function(el) {\n    var box, doc, docEl, k, origin, v, _ref;\n    if (el === document) {\n      doc = document;\n      el = document.documentElement;\n    } else {\n      doc = el.ownerDocument;\n    }\n    docEl = doc.documentElement;\n    box = {};\n    _ref = el.getBoundingClientRect();\n    for (k in _ref) {\n      v = _ref[k];\n      box[k] = v;\n    }\n    origin = getOrigin(doc);\n    box.top -= origin.top;\n    box.left -= origin.left;\n    if (box.width == null) {\n      box.width = document.body.scrollWidth - box.left - box.right;\n    }\n    if (box.height == null) {\n      box.height = document.body.scrollHeight - box.top - box.bottom;\n    }\n    box.top = box.top - docEl.clientTop;\n    box.left = box.left - docEl.clientLeft;\n    box.right = doc.body.clientWidth - box.width - box.left;\n    box.bottom = doc.body.clientHeight - box.height - box.top;\n    return box;\n  };\n\n  getOffsetParent = function(el) {\n    return el.offsetParent || document.documentElement;\n  };\n\n  getScrollBarSize = function() {\n    var inner, outer, width, widthContained, widthScroll;\n    inner = document.createElement('div');\n    inner.style.width = '100%';\n    inner.style.height = '200px';\n    outer = document.createElement('div');\n    extend(outer.style, {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      pointerEvents: 'none',\n      visibility: 'hidden',\n      width: '200px',\n      height: '150px',\n      overflow: 'hidden'\n    });\n    outer.appendChild(inner);\n    document.body.appendChild(outer);\n    widthContained = inner.offsetWidth;\n    outer.style.overflow = 'scroll';\n    widthScroll = inner.offsetWidth;\n    if (widthContained === widthScroll) {\n      widthScroll = outer.clientWidth;\n    }\n    document.body.removeChild(outer);\n    width = widthContained - widthScroll;\n    return {\n      width: width,\n      height: width\n    };\n  };\n\n  extend = function(out) {\n    var args, key, obj, val, _i, _len, _ref;\n    if (out == null) {\n      out = {};\n    }\n    args = [];\n    Array.prototype.push.apply(args, arguments);\n    _ref = args.slice(1);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      obj = _ref[_i];\n      if (obj) {\n        for (key in obj) {\n          if (!__hasProp.call(obj, key)) continue;\n          val = obj[key];\n          out[key] = val;\n        }\n      }\n    }\n    return out;\n  };\n\n  removeClass = function(el, name) {\n    var cls, _i, _len, _ref, _results;\n    if (el.classList != null) {\n      _ref = name.split(' ');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        cls = _ref[_i];\n        if (cls.trim()) {\n          _results.push(el.classList.remove(cls));\n        }\n      }\n      return _results;\n    } else {\n      return el.className = el.className.replace(new RegExp(\"(^| )\" + (name.split(' ').join('|')) + \"( |$)\", 'gi'), ' ');\n    }\n  };\n\n  addClass = function(el, name) {\n    var cls, _i, _len, _ref, _results;\n    if (el.classList != null) {\n      _ref = name.split(' ');\n      _results = [];\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        cls = _ref[_i];\n        if (cls.trim()) {\n          _results.push(el.classList.add(cls));\n        }\n      }\n      return _results;\n    } else {\n      removeClass(el, name);\n      return el.className += \" \" + name;\n    }\n  };\n\n  hasClass = function(el, name) {\n    if (el.classList != null) {\n      return el.classList.contains(name);\n    } else {\n      return new RegExp(\"(^| )\" + name + \"( |$)\", 'gi').test(el.className);\n    }\n  };\n\n  updateClasses = function(el, add, all) {\n    var cls, _i, _j, _len, _len1, _results;\n    for (_i = 0, _len = all.length; _i < _len; _i++) {\n      cls = all[_i];\n      if (__indexOf.call(add, cls) < 0) {\n        if (hasClass(el, cls)) {\n          removeClass(el, cls);\n        }\n      }\n    }\n    _results = [];\n    for (_j = 0, _len1 = add.length; _j < _len1; _j++) {\n      cls = add[_j];\n      if (!hasClass(el, cls)) {\n        _results.push(addClass(el, cls));\n      } else {\n        _results.push(void 0);\n      }\n    }\n    return _results;\n  };\n\n  deferred = [];\n\n  defer = function(fn) {\n    return deferred.push(fn);\n  };\n\n  flush = function() {\n    var fn, _results;\n    _results = [];\n    while (fn = deferred.pop()) {\n      _results.push(fn());\n    }\n    return _results;\n  };\n\n  Evented = (function() {\n    function Evented() {}\n\n    Evented.prototype.on = function(event, handler, ctx, once) {\n      var _base;\n      if (once == null) {\n        once = false;\n      }\n      if (this.bindings == null) {\n        this.bindings = {};\n      }\n      if ((_base = this.bindings)[event] == null) {\n        _base[event] = [];\n      }\n      return this.bindings[event].push({\n        handler: handler,\n        ctx: ctx,\n        once: once\n      });\n    };\n\n    Evented.prototype.once = function(event, handler, ctx) {\n      return this.on(event, handler, ctx, true);\n    };\n\n    Evented.prototype.off = function(event, handler) {\n      var i, _ref, _results;\n      if (((_ref = this.bindings) != null ? _ref[event] : void 0) == null) {\n        return;\n      }\n      if (handler == null) {\n        return delete this.bindings[event];\n      } else {\n        i = 0;\n        _results = [];\n        while (i < this.bindings[event].length) {\n          if (this.bindings[event][i].handler === handler) {\n            _results.push(this.bindings[event].splice(i, 1));\n          } else {\n            _results.push(i++);\n          }\n        }\n        return _results;\n      }\n    };\n\n    Evented.prototype.trigger = function() {\n      var args, ctx, event, handler, i, once, _ref, _ref1, _results;\n      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];\n      if ((_ref = this.bindings) != null ? _ref[event] : void 0) {\n        i = 0;\n        _results = [];\n        while (i < this.bindings[event].length) {\n          _ref1 = this.bindings[event][i], handler = _ref1.handler, ctx = _ref1.ctx, once = _ref1.once;\n          handler.apply(ctx != null ? ctx : this, args);\n          if (once) {\n            _results.push(this.bindings[event].splice(i, 1));\n          } else {\n            _results.push(i++);\n          }\n        }\n        return _results;\n      }\n    };\n\n    return Evented;\n\n  })();\n\n  this.Tether.Utils = {\n    getScrollParent: getScrollParent,\n    getBounds: getBounds,\n    getOffsetParent: getOffsetParent,\n    extend: extend,\n    addClass: addClass,\n    removeClass: removeClass,\n    hasClass: hasClass,\n    updateClasses: updateClasses,\n    defer: defer,\n    flush: flush,\n    uniqueId: uniqueId,\n    Evented: Evented,\n    getScrollBarSize: getScrollBarSize\n  };\n\n}).call(this);\n\n(function() {\n  var MIRROR_LR, MIRROR_TB, OFFSET_MAP, Tether, addClass, addOffset, attachmentToOffset, autoToFixedAttachment, defer, extend, flush, getBounds, getOffsetParent, getOuterSize, getScrollBarSize, getScrollParent, getSize, now, offsetToPx, parseAttachment, parseOffset, position, removeClass, tethers, transformKey, updateClasses, within, _Tether, _ref,\n    __slice = [].slice,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  if (this.Tether == null) {\n    throw new Error(\"You must include the utils.js file before tether.js\");\n  }\n\n  Tether = this.Tether;\n\n  _ref = Tether.Utils, getScrollParent = _ref.getScrollParent, getSize = _ref.getSize, getOuterSize = _ref.getOuterSize, getBounds = _ref.getBounds, getOffsetParent = _ref.getOffsetParent, extend = _ref.extend, addClass = _ref.addClass, removeClass = _ref.removeClass, updateClasses = _ref.updateClasses, defer = _ref.defer, flush = _ref.flush, getScrollBarSize = _ref.getScrollBarSize;\n\n  within = function(a, b, diff) {\n    if (diff == null) {\n      diff = 1;\n    }\n    return (a + diff >= b && b >= a - diff);\n  };\n\n  transformKey = (function() {\n    var el, key, _i, _len, _ref1;\n    el = document.createElement('div');\n    _ref1 = ['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      key = _ref1[_i];\n      if (el.style[key] !== void 0) {\n        return key;\n      }\n    }\n  })();\n\n  tethers = [];\n\n  position = function() {\n    var tether, _i, _len;\n    for (_i = 0, _len = tethers.length; _i < _len; _i++) {\n      tether = tethers[_i];\n      tether.position(false);\n    }\n    return flush();\n  };\n\n  now = function() {\n    var _ref1;\n    return (_ref1 = typeof performance !== \"undefined\" && performance !== null ? typeof performance.now === \"function\" ? performance.now() : void 0 : void 0) != null ? _ref1 : +(new Date);\n  };\n\n  (function() {\n    var event, lastCall, lastDuration, pendingTimeout, tick, _i, _len, _ref1, _results;\n    lastCall = null;\n    lastDuration = null;\n    pendingTimeout = null;\n    tick = function() {\n      if ((lastDuration != null) && lastDuration > 16) {\n        lastDuration = Math.min(lastDuration - 16, 250);\n        pendingTimeout = setTimeout(tick, 250);\n        return;\n      }\n      if ((lastCall != null) && (now() - lastCall) < 10) {\n        return;\n      }\n      if (pendingTimeout != null) {\n        clearTimeout(pendingTimeout);\n        pendingTimeout = null;\n      }\n      lastCall = now();\n      position();\n      return lastDuration = now() - lastCall;\n    };\n    _ref1 = ['resize', 'scroll', 'touchmove'];\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      event = _ref1[_i];\n      _results.push(window.addEventListener(event, tick));\n    }\n    return _results;\n  })();\n\n  MIRROR_LR = {\n    center: 'center',\n    left: 'right',\n    right: 'left'\n  };\n\n  MIRROR_TB = {\n    middle: 'middle',\n    top: 'bottom',\n    bottom: 'top'\n  };\n\n  OFFSET_MAP = {\n    top: 0,\n    left: 0,\n    middle: '50%',\n    center: '50%',\n    bottom: '100%',\n    right: '100%'\n  };\n\n  autoToFixedAttachment = function(attachment, relativeToAttachment) {\n    var left, top;\n    left = attachment.left, top = attachment.top;\n    if (left === 'auto') {\n      left = MIRROR_LR[relativeToAttachment.left];\n    }\n    if (top === 'auto') {\n      top = MIRROR_TB[relativeToAttachment.top];\n    }\n    return {\n      left: left,\n      top: top\n    };\n  };\n\n  attachmentToOffset = function(attachment) {\n    var _ref1, _ref2;\n    return {\n      left: (_ref1 = OFFSET_MAP[attachment.left]) != null ? _ref1 : attachment.left,\n      top: (_ref2 = OFFSET_MAP[attachment.top]) != null ? _ref2 : attachment.top\n    };\n  };\n\n  addOffset = function() {\n    var left, offsets, out, top, _i, _len, _ref1;\n    offsets = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n    out = {\n      top: 0,\n      left: 0\n    };\n    for (_i = 0, _len = offsets.length; _i < _len; _i++) {\n      _ref1 = offsets[_i], top = _ref1.top, left = _ref1.left;\n      if (typeof top === 'string') {\n        top = parseFloat(top, 10);\n      }\n      if (typeof left === 'string') {\n        left = parseFloat(left, 10);\n      }\n      out.top += top;\n      out.left += left;\n    }\n    return out;\n  };\n\n  offsetToPx = function(offset, size) {\n    if (typeof offset.left === 'string' && offset.left.indexOf('%') !== -1) {\n      offset.left = parseFloat(offset.left, 10) / 100 * size.width;\n    }\n    if (typeof offset.top === 'string' && offset.top.indexOf('%') !== -1) {\n      offset.top = parseFloat(offset.top, 10) / 100 * size.height;\n    }\n    return offset;\n  };\n\n  parseAttachment = parseOffset = function(value) {\n    var left, top, _ref1;\n    _ref1 = value.split(' '), top = _ref1[0], left = _ref1[1];\n    return {\n      top: top,\n      left: left\n    };\n  };\n\n  _Tether = (function() {\n    _Tether.modules = [];\n\n    function _Tether(options) {\n      this.position = __bind(this.position, this);\n      var module, _i, _len, _ref1, _ref2;\n      tethers.push(this);\n      this.history = [];\n      this.setOptions(options, false);\n      _ref1 = Tether.modules;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        module = _ref1[_i];\n        if ((_ref2 = module.initialize) != null) {\n          _ref2.call(this);\n        }\n      }\n      this.position();\n    }\n\n    _Tether.prototype.getClass = function(key) {\n      var _ref1, _ref2;\n      if ((_ref1 = this.options.classes) != null ? _ref1[key] : void 0) {\n        return this.options.classes[key];\n      } else if (((_ref2 = this.options.classes) != null ? _ref2[key] : void 0) !== false) {\n        if (this.options.classPrefix) {\n          return \"\" + this.options.classPrefix + \"-\" + key;\n        } else {\n          return key;\n        }\n      } else {\n        return '';\n      }\n    };\n\n    _Tether.prototype.setOptions = function(options, position) {\n      var defaults, key, _i, _len, _ref1, _ref2;\n      this.options = options;\n      if (position == null) {\n        position = true;\n      }\n      defaults = {\n        offset: '0 0',\n        targetOffset: '0 0',\n        targetAttachment: 'auto auto',\n        classPrefix: 'tether'\n      };\n      this.options = extend(defaults, this.options);\n      _ref1 = this.options, this.element = _ref1.element, this.target = _ref1.target, this.targetModifier = _ref1.targetModifier;\n      if (this.target === 'viewport') {\n        this.target = document.body;\n        this.targetModifier = 'visible';\n      } else if (this.target === 'scroll-handle') {\n        this.target = document.body;\n        this.targetModifier = 'scroll-handle';\n      }\n      _ref2 = ['element', 'target'];\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        key = _ref2[_i];\n        if (this[key] == null) {\n          throw new Error(\"Tether Error: Both element and target must be defined\");\n        }\n        if (this[key].jquery != null) {\n          this[key] = this[key][0];\n        } else if (typeof this[key] === 'string') {\n          this[key] = document.querySelector(this[key]);\n        }\n      }\n      addClass(this.element, this.getClass('element'));\n      addClass(this.target, this.getClass('target'));\n      if (!this.options.attachment) {\n        throw new Error(\"Tether Error: You must provide an attachment\");\n      }\n      this.targetAttachment = parseAttachment(this.options.targetAttachment);\n      this.attachment = parseAttachment(this.options.attachment);\n      this.offset = parseOffset(this.options.offset);\n      this.targetOffset = parseOffset(this.options.targetOffset);\n      if (this.scrollParent != null) {\n        this.disable();\n      }\n      if (this.targetModifier === 'scroll-handle') {\n        this.scrollParent = this.target;\n      } else {\n        this.scrollParent = getScrollParent(this.target);\n      }\n      if (this.options.enabled !== false) {\n        return this.enable(position);\n      }\n    };\n\n    _Tether.prototype.getTargetBounds = function() {\n      var bounds, fitAdj, hasBottomScroll, height, out, scrollBottom, scrollPercentage, style, target;\n      if (this.targetModifier != null) {\n        switch (this.targetModifier) {\n          case 'visible':\n            if (this.target === document.body) {\n              return {\n                top: pageYOffset,\n                left: pageXOffset,\n                height: innerHeight,\n                width: innerWidth\n              };\n            } else {\n              bounds = getBounds(this.target);\n              out = {\n                height: bounds.height,\n                width: bounds.width,\n                top: bounds.top,\n                left: bounds.left\n              };\n              out.height = Math.min(out.height, bounds.height - (pageYOffset - bounds.top));\n              out.height = Math.min(out.height, bounds.height - ((bounds.top + bounds.height) - (pageYOffset + innerHeight)));\n              out.height = Math.min(innerHeight, out.height);\n              out.height -= 2;\n              out.width = Math.min(out.width, bounds.width - (pageXOffset - bounds.left));\n              out.width = Math.min(out.width, bounds.width - ((bounds.left + bounds.width) - (pageXOffset + innerWidth)));\n              out.width = Math.min(innerWidth, out.width);\n              out.width -= 2;\n              if (out.top < pageYOffset) {\n                out.top = pageYOffset;\n              }\n              if (out.left < pageXOffset) {\n                out.left = pageXOffset;\n              }\n              return out;\n            }\n            break;\n          case 'scroll-handle':\n            target = this.target;\n            if (target === document.body) {\n              target = document.documentElement;\n              bounds = {\n                left: pageXOffset,\n                top: pageYOffset,\n                height: innerHeight,\n                width: innerWidth\n              };\n            } else {\n              bounds = getBounds(target);\n            }\n            style = getComputedStyle(target);\n            hasBottomScroll = target.scrollWidth > target.clientWidth || 'scroll' === [style.overflow, style.overflowX] || this.target !== document.body;\n            scrollBottom = 0;\n            if (hasBottomScroll) {\n              scrollBottom = 15;\n            }\n            height = bounds.height - parseFloat(style.borderTopWidth) - parseFloat(style.borderBottomWidth) - scrollBottom;\n            out = {\n              width: 15,\n              height: height * 0.975 * (height / target.scrollHeight),\n              left: bounds.left + bounds.width - parseFloat(style.borderLeftWidth) - 15\n            };\n            fitAdj = 0;\n            if (height < 408 && this.target === document.body) {\n              fitAdj = -0.00011 * Math.pow(height, 2) - 0.00727 * height + 22.58;\n            }\n            if (this.target !== document.body) {\n              out.height = Math.max(out.height, 24);\n            }\n            scrollPercentage = this.target.scrollTop / (target.scrollHeight - height);\n            out.top = scrollPercentage * (height - out.height - fitAdj) + bounds.top + parseFloat(style.borderTopWidth);\n            if (this.target === document.body) {\n              out.height = Math.max(out.height, 24);\n            }\n            return out;\n        }\n      } else {\n        return getBounds(this.target);\n      }\n    };\n\n    _Tether.prototype.clearCache = function() {\n      return this._cache = {};\n    };\n\n    _Tether.prototype.cache = function(k, getter) {\n      if (this._cache == null) {\n        this._cache = {};\n      }\n      if (this._cache[k] == null) {\n        this._cache[k] = getter.call(this);\n      }\n      return this._cache[k];\n    };\n\n    _Tether.prototype.enable = function(position) {\n      if (position == null) {\n        position = true;\n      }\n      addClass(this.target, this.getClass('enabled'));\n      addClass(this.element, this.getClass('enabled'));\n      this.enabled = true;\n      if (this.scrollParent !== document) {\n        this.scrollParent.addEventListener('scroll', this.position);\n      }\n      if (position) {\n        return this.position();\n      }\n    };\n\n    _Tether.prototype.disable = function() {\n      removeClass(this.target, this.getClass('enabled'));\n      removeClass(this.element, this.getClass('enabled'));\n      this.enabled = false;\n      if (this.scrollParent != null) {\n        return this.scrollParent.removeEventListener('scroll', this.position);\n      }\n    };\n\n    _Tether.prototype.destroy = function() {\n      var i, tether, _i, _len, _results;\n      this.disable();\n      _results = [];\n      for (i = _i = 0, _len = tethers.length; _i < _len; i = ++_i) {\n        tether = tethers[i];\n        if (tether === this) {\n          tethers.splice(i, 1);\n          break;\n        } else {\n          _results.push(void 0);\n        }\n      }\n      return _results;\n    };\n\n    _Tether.prototype.updateAttachClasses = function(elementAttach, targetAttach) {\n      var add, all, side, sides, _i, _j, _len, _len1, _ref1,\n        _this = this;\n      if (elementAttach == null) {\n        elementAttach = this.attachment;\n      }\n      if (targetAttach == null) {\n        targetAttach = this.targetAttachment;\n      }\n      sides = ['left', 'top', 'bottom', 'right', 'middle', 'center'];\n      if ((_ref1 = this._addAttachClasses) != null ? _ref1.length : void 0) {\n        this._addAttachClasses.splice(0, this._addAttachClasses.length);\n      }\n      add = this._addAttachClasses != null ? this._addAttachClasses : this._addAttachClasses = [];\n      if (elementAttach.top) {\n        add.push(\"\" + (this.getClass('element-attached')) + \"-\" + elementAttach.top);\n      }\n      if (elementAttach.left) {\n        add.push(\"\" + (this.getClass('element-attached')) + \"-\" + elementAttach.left);\n      }\n      if (targetAttach.top) {\n        add.push(\"\" + (this.getClass('target-attached')) + \"-\" + targetAttach.top);\n      }\n      if (targetAttach.left) {\n        add.push(\"\" + (this.getClass('target-attached')) + \"-\" + targetAttach.left);\n      }\n      all = [];\n      for (_i = 0, _len = sides.length; _i < _len; _i++) {\n        side = sides[_i];\n        all.push(\"\" + (this.getClass('element-attached')) + \"-\" + side);\n      }\n      for (_j = 0, _len1 = sides.length; _j < _len1; _j++) {\n        side = sides[_j];\n        all.push(\"\" + (this.getClass('target-attached')) + \"-\" + side);\n      }\n      return defer(function() {\n        if (_this._addAttachClasses == null) {\n          return;\n        }\n        updateClasses(_this.element, _this._addAttachClasses, all);\n        updateClasses(_this.target, _this._addAttachClasses, all);\n        return _this._addAttachClasses = void 0;\n      });\n    };\n\n    _Tether.prototype.position = function(flushChanges) {\n      var elementPos, elementStyle, height, left, manualOffset, manualTargetOffset, module, next, offset, offsetBorder, offsetParent, offsetParentSize, offsetParentStyle, offsetPosition, ret, scrollLeft, scrollTop, scrollbarSize, side, targetAttachment, targetOffset, targetPos, targetSize, top, width, _i, _j, _len, _len1, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6,\n        _this = this;\n      if (flushChanges == null) {\n        flushChanges = true;\n      }\n      if (!this.enabled) {\n        return;\n      }\n      this.clearCache();\n      targetAttachment = autoToFixedAttachment(this.targetAttachment, this.attachment);\n      this.updateAttachClasses(this.attachment, targetAttachment);\n      elementPos = this.cache('element-bounds', function() {\n        return getBounds(_this.element);\n      });\n      width = elementPos.width, height = elementPos.height;\n      if (width === 0 && height === 0 && (this.lastSize != null)) {\n        _ref1 = this.lastSize, width = _ref1.width, height = _ref1.height;\n      } else {\n        this.lastSize = {\n          width: width,\n          height: height\n        };\n      }\n      targetSize = targetPos = this.cache('target-bounds', function() {\n        return _this.getTargetBounds();\n      });\n      offset = offsetToPx(attachmentToOffset(this.attachment), {\n        width: width,\n        height: height\n      });\n      targetOffset = offsetToPx(attachmentToOffset(targetAttachment), targetSize);\n      manualOffset = offsetToPx(this.offset, {\n        width: width,\n        height: height\n      });\n      manualTargetOffset = offsetToPx(this.targetOffset, targetSize);\n      offset = addOffset(offset, manualOffset);\n      targetOffset = addOffset(targetOffset, manualTargetOffset);\n      left = targetPos.left + targetOffset.left - offset.left;\n      top = targetPos.top + targetOffset.top - offset.top;\n      _ref2 = Tether.modules;\n      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n        module = _ref2[_i];\n        ret = module.position.call(this, {\n          left: left,\n          top: top,\n          targetAttachment: targetAttachment,\n          targetPos: targetPos,\n          attachment: this.attachment,\n          elementPos: elementPos,\n          offset: offset,\n          targetOffset: targetOffset,\n          manualOffset: manualOffset,\n          manualTargetOffset: manualTargetOffset,\n          scrollbarSize: scrollbarSize\n        });\n        if ((ret == null) || typeof ret !== 'object') {\n          continue;\n        } else if (ret === false) {\n          return false;\n        } else {\n          top = ret.top, left = ret.left;\n        }\n      }\n      next = {\n        page: {\n          top: top,\n          left: left\n        },\n        viewport: {\n          top: top - pageYOffset,\n          bottom: pageYOffset - top - height + innerHeight,\n          left: left - pageXOffset,\n          right: pageXOffset - left - width + innerWidth\n        }\n      };\n      if (document.body.scrollWidth > window.innerWidth) {\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n        next.viewport.bottom -= scrollbarSize.height;\n      }\n      if (document.body.scrollHeight > window.innerHeight) {\n        scrollbarSize = this.cache('scrollbar-size', getScrollBarSize);\n        next.viewport.right -= scrollbarSize.width;\n      }\n      if (((_ref3 = document.body.style.position) !== '' && _ref3 !== 'static') || ((_ref4 = document.body.parentElement.style.position) !== '' && _ref4 !== 'static')) {\n        next.page.bottom = document.body.scrollHeight - top - height;\n        next.page.right = document.body.scrollWidth - left - width;\n      }\n      if (((_ref5 = this.options.optimizations) != null ? _ref5.moveElement : void 0) !== false && (this.targetModifier == null)) {\n        offsetParent = this.cache('target-offsetparent', function() {\n          return getOffsetParent(_this.target);\n        });\n        offsetPosition = this.cache('target-offsetparent-bounds', function() {\n          return getBounds(offsetParent);\n        });\n        offsetParentStyle = getComputedStyle(offsetParent);\n        elementStyle = getComputedStyle(this.element);\n        offsetParentSize = offsetPosition;\n        offsetBorder = {};\n        _ref6 = ['Top', 'Left', 'Bottom', 'Right'];\n        for (_j = 0, _len1 = _ref6.length; _j < _len1; _j++) {\n          side = _ref6[_j];\n          offsetBorder[side.toLowerCase()] = parseFloat(offsetParentStyle[\"border\" + side + \"Width\"]);\n        }\n        offsetPosition.right = document.body.scrollWidth - offsetPosition.left - offsetParentSize.width + offsetBorder.right;\n        offsetPosition.bottom = document.body.scrollHeight - offsetPosition.top - offsetParentSize.height + offsetBorder.bottom;\n        if (next.page.top >= (offsetPosition.top + offsetBorder.top) && next.page.bottom >= offsetPosition.bottom) {\n          if (next.page.left >= (offsetPosition.left + offsetBorder.left) && next.page.right >= offsetPosition.right) {\n            scrollTop = offsetParent.scrollTop;\n            scrollLeft = offsetParent.scrollLeft;\n            next.offset = {\n              top: next.page.top - offsetPosition.top + scrollTop - offsetBorder.top,\n              left: next.page.left - offsetPosition.left + scrollLeft - offsetBorder.left\n            };\n          }\n        }\n      }\n      this.move(next);\n      this.history.unshift(next);\n      if (this.history.length > 3) {\n        this.history.pop();\n      }\n      if (flushChanges) {\n        flush();\n      }\n      return true;\n    };\n\n    _Tether.prototype.move = function(position) {\n      var css, elVal, found, key, moved, offsetParent, point, same, transcribe, type, val, write, writeCSS, _i, _len, _ref1, _ref2,\n        _this = this;\n      if (this.element.parentNode == null) {\n        return;\n      }\n      same = {};\n      for (type in position) {\n        same[type] = {};\n        for (key in position[type]) {\n          found = false;\n          _ref1 = this.history;\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n            point = _ref1[_i];\n            if (!within((_ref2 = point[type]) != null ? _ref2[key] : void 0, position[type][key])) {\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            same[type][key] = true;\n          }\n        }\n      }\n      css = {\n        top: '',\n        left: '',\n        right: '',\n        bottom: ''\n      };\n      transcribe = function(same, pos) {\n        var xPos, yPos, _ref3;\n        if (((_ref3 = _this.options.optimizations) != null ? _ref3.gpu : void 0) !== false) {\n          if (same.top) {\n            css.top = 0;\n            yPos = pos.top;\n          } else {\n            css.bottom = 0;\n            yPos = -pos.bottom;\n          }\n          if (same.left) {\n            css.left = 0;\n            xPos = pos.left;\n          } else {\n            css.right = 0;\n            xPos = -pos.right;\n          }\n          css[transformKey] = \"translateX(\" + (Math.round(xPos)) + \"px) translateY(\" + (Math.round(yPos)) + \"px)\";\n          if (transformKey !== 'msTransform') {\n            return css[transformKey] += \" translateZ(0)\";\n          }\n        } else {\n          if (same.top) {\n            css.top = \"\" + pos.top + \"px\";\n          } else {\n            css.bottom = \"\" + pos.bottom + \"px\";\n          }\n          if (same.left) {\n            return css.left = \"\" + pos.left + \"px\";\n          } else {\n            return css.right = \"\" + pos.right + \"px\";\n          }\n        }\n      };\n      moved = false;\n      if ((same.page.top || same.page.bottom) && (same.page.left || same.page.right)) {\n        css.position = 'absolute';\n        transcribe(same.page, position.page);\n      } else if ((same.viewport.top || same.viewport.bottom) && (same.viewport.left || same.viewport.right)) {\n        css.position = 'fixed';\n        transcribe(same.viewport, position.viewport);\n      } else if ((same.offset != null) && same.offset.top && same.offset.left) {\n        css.position = 'absolute';\n        offsetParent = this.cache('target-offsetparent', function() {\n          return getOffsetParent(_this.target);\n        });\n        if (getOffsetParent(this.element) !== offsetParent) {\n          defer(function() {\n            _this.element.parentNode.removeChild(_this.element);\n            return offsetParent.appendChild(_this.element);\n          });\n        }\n        transcribe(same.offset, position.offset);\n        moved = true;\n      } else {\n        css.position = 'absolute';\n        transcribe({\n          top: true,\n          left: true\n        }, position.page);\n      }\n      if (!moved && this.element.parentNode.tagName !== 'BODY') {\n        this.element.parentNode.removeChild(this.element);\n        document.body.appendChild(this.element);\n      }\n      writeCSS = {};\n      write = false;\n      for (key in css) {\n        val = css[key];\n        elVal = this.element.style[key];\n        if (elVal !== '' && val !== '' && (key === 'top' || key === 'left' || key === 'bottom' || key === 'right')) {\n          elVal = parseFloat(elVal);\n          val = parseFloat(val);\n        }\n        if (elVal !== val) {\n          write = true;\n          writeCSS[key] = css[key];\n        }\n      }\n      if (write) {\n        return defer(function() {\n          return extend(_this.element.style, writeCSS);\n        });\n      }\n    };\n\n    return _Tether;\n\n  })();\n\n  Tether.position = position;\n\n  this.Tether = extend(_Tether, Tether);\n\n}).call(this);\n\n(function() {\n  var BOUNDS_FORMAT, MIRROR_ATTACH, defer, extend, getBoundingRect, getBounds, getOuterSize, getSize, updateClasses, _ref,\n    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };\n\n  _ref = this.Tether.Utils, getOuterSize = _ref.getOuterSize, getBounds = _ref.getBounds, getSize = _ref.getSize, extend = _ref.extend, updateClasses = _ref.updateClasses, defer = _ref.defer;\n\n  MIRROR_ATTACH = {\n    left: 'right',\n    right: 'left',\n    top: 'bottom',\n    bottom: 'top',\n    middle: 'middle'\n  };\n\n  BOUNDS_FORMAT = ['left', 'top', 'right', 'bottom'];\n\n  getBoundingRect = function(tether, to) {\n    var i, pos, side, size, style, _i, _len;\n    if (to === 'scrollParent') {\n      to = tether.scrollParent;\n    } else if (to === 'window') {\n      to = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset];\n    }\n    if (to === document) {\n      to = to.documentElement;\n    }\n    if (to.nodeType != null) {\n      pos = size = getBounds(to);\n      style = getComputedStyle(to);\n      to = [pos.left, pos.top, size.width + pos.left, size.height + pos.top];\n      for (i = _i = 0, _len = BOUNDS_FORMAT.length; _i < _len; i = ++_i) {\n        side = BOUNDS_FORMAT[i];\n        side = side[0].toUpperCase() + side.substr(1);\n        if (side === 'Top' || side === 'Left') {\n          to[i] += parseFloat(style[\"border\" + side + \"Width\"]);\n        } else {\n          to[i] -= parseFloat(style[\"border\" + side + \"Width\"]);\n        }\n      }\n    }\n    return to;\n  };\n\n  this.Tether.modules.push({\n    position: function(_arg) {\n      var addClasses, allClasses, attachment, bounds, changeAttachX, changeAttachY, cls, constraint, eAttachment, height, left, oob, oobClass, p, pin, pinned, pinnedClass, removeClass, side, tAttachment, targetAttachment, targetHeight, targetSize, targetWidth, to, top, width, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,\n        _this = this;\n      top = _arg.top, left = _arg.left, targetAttachment = _arg.targetAttachment;\n      if (!this.options.constraints) {\n        return true;\n      }\n      removeClass = function(prefix) {\n        var side, _i, _len, _results;\n        _this.removeClass(prefix);\n        _results = [];\n        for (_i = 0, _len = BOUNDS_FORMAT.length; _i < _len; _i++) {\n          side = BOUNDS_FORMAT[_i];\n          _results.push(_this.removeClass(\"\" + prefix + \"-\" + side));\n        }\n        return _results;\n      };\n      _ref1 = this.cache('element-bounds', function() {\n        return getBounds(_this.element);\n      }), height = _ref1.height, width = _ref1.width;\n      if (width === 0 && height === 0 && (this.lastSize != null)) {\n        _ref2 = this.lastSize, width = _ref2.width, height = _ref2.height;\n      }\n      targetSize = this.cache('target-bounds', function() {\n        return _this.getTargetBounds();\n      });\n      targetHeight = targetSize.height;\n      targetWidth = targetSize.width;\n      tAttachment = {};\n      eAttachment = {};\n      allClasses = [this.getClass('pinned'), this.getClass('out-of-bounds')];\n      _ref3 = this.options.constraints;\n      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {\n        constraint = _ref3[_i];\n        if (constraint.outOfBoundsClass) {\n          allClasses.push(constraint.outOfBoundsClass);\n        }\n        if (constraint.pinnedClass) {\n          allClasses.push(constraint.pinnedClass);\n        }\n      }\n      for (_j = 0, _len1 = allClasses.length; _j < _len1; _j++) {\n        cls = allClasses[_j];\n        _ref4 = ['left', 'top', 'right', 'bottom'];\n        for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {\n          side = _ref4[_k];\n          allClasses.push(\"\" + cls + \"-\" + side);\n        }\n      }\n      addClasses = [];\n      tAttachment = extend({}, targetAttachment);\n      eAttachment = extend({}, this.attachment);\n      _ref5 = this.options.constraints;\n      for (_l = 0, _len3 = _ref5.length; _l < _len3; _l++) {\n        constraint = _ref5[_l];\n        to = constraint.to, attachment = constraint.attachment, pin = constraint.pin;\n        if (attachment == null) {\n          attachment = '';\n        }\n        if (__indexOf.call(attachment, ' ') >= 0) {\n          _ref6 = attachment.split(' '), changeAttachY = _ref6[0], changeAttachX = _ref6[1];\n        } else {\n          changeAttachX = changeAttachY = attachment;\n        }\n        bounds = getBoundingRect(this, to);\n        if (changeAttachY === 'target' || changeAttachY === 'both') {\n          if (top < bounds[1] && tAttachment.top === 'top') {\n            top += targetHeight;\n            tAttachment.top = 'bottom';\n          }\n          if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n            top -= targetHeight;\n            tAttachment.top = 'top';\n          }\n        }\n        if (changeAttachY === 'together') {\n          if (top < bounds[1] && tAttachment.top === 'top') {\n            if (eAttachment.top === 'bottom') {\n              top += targetHeight;\n              tAttachment.top = 'bottom';\n              top += height;\n              eAttachment.top = 'top';\n            } else if (eAttachment.top === 'top') {\n              top += targetHeight;\n              tAttachment.top = 'bottom';\n              top -= height;\n              eAttachment.top = 'bottom';\n            }\n          }\n          if (top + height > bounds[3] && tAttachment.top === 'bottom') {\n            if (eAttachment.top === 'top') {\n              top -= targetHeight;\n              tAttachment.top = 'top';\n              top -= height;\n              eAttachment.top = 'bottom';\n            } else if (eAttachment.top === 'bottom') {\n              top -= targetHeight;\n              tAttachment.top = 'top';\n              top += height;\n              eAttachment.top = 'top';\n            }\n          }\n          if (tAttachment.top === 'middle') {\n            if (top + height > bounds[3] && eAttachment.top === 'top') {\n              top -= height;\n              eAttachment.top = 'bottom';\n            } else if (top < bounds[1] && eAttachment.top === 'bottom') {\n              top += height;\n              eAttachment.top = 'top';\n            }\n          }\n        }\n        if (changeAttachX === 'target' || changeAttachX === 'both') {\n          if (left < bounds[0] && tAttachment.left === 'left') {\n            left += targetWidth;\n            tAttachment.left = 'right';\n          }\n          if (left + width > bounds[2] && tAttachment.left === 'right') {\n            left -= targetWidth;\n            tAttachment.left = 'left';\n          }\n        }\n        if (changeAttachX === 'together') {\n          if (left < bounds[0] && tAttachment.left === 'left') {\n            if (eAttachment.left === 'right') {\n              left += targetWidth;\n              tAttachment.left = 'right';\n              left += width;\n              eAttachment.left = 'left';\n            } else if (eAttachment.left === 'left') {\n              left += targetWidth;\n              tAttachment.left = 'right';\n              left -= width;\n              eAttachment.left = 'right';\n            }\n          } else if (left + width > bounds[2] && tAttachment.left === 'right') {\n            if (eAttachment.left === 'left') {\n              left -= targetWidth;\n              tAttachment.left = 'left';\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (eAttachment.left === 'right') {\n              left -= targetWidth;\n              tAttachment.left = 'left';\n              left += width;\n              eAttachment.left = 'left';\n            }\n          } else if (tAttachment.left === 'center') {\n            if (left + width > bounds[2] && eAttachment.left === 'left') {\n              left -= width;\n              eAttachment.left = 'right';\n            } else if (left < bounds[0] && eAttachment.left === 'right') {\n              left += width;\n              eAttachment.left = 'left';\n            }\n          }\n        }\n        if (changeAttachY === 'element' || changeAttachY === 'both') {\n          if (top < bounds[1] && eAttachment.top === 'bottom') {\n            top += height;\n            eAttachment.top = 'top';\n          }\n          if (top + height > bounds[3] && eAttachment.top === 'top') {\n            top -= height;\n            eAttachment.top = 'bottom';\n          }\n        }\n        if (changeAttachX === 'element' || changeAttachX === 'both') {\n          if (left < bounds[0] && eAttachment.left === 'right') {\n            left += width;\n            eAttachment.left = 'left';\n          }\n          if (left + width > bounds[2] && eAttachment.left === 'left') {\n            left -= width;\n            eAttachment.left = 'right';\n          }\n        }\n        if (typeof pin === 'string') {\n          pin = (function() {\n            var _len4, _m, _ref7, _results;\n            _ref7 = pin.split(',');\n            _results = [];\n            for (_m = 0, _len4 = _ref7.length; _m < _len4; _m++) {\n              p = _ref7[_m];\n              _results.push(p.trim());\n            }\n            return _results;\n          })();\n        } else if (pin === true) {\n          pin = ['top', 'left', 'right', 'bottom'];\n        }\n        pin || (pin = []);\n        pinned = [];\n        oob = [];\n        if (top < bounds[1]) {\n          if (__indexOf.call(pin, 'top') >= 0) {\n            top = bounds[1];\n            pinned.push('top');\n          } else {\n            oob.push('top');\n          }\n        }\n        if (top + height > bounds[3]) {\n          if (__indexOf.call(pin, 'bottom') >= 0) {\n            top = bounds[3] - height;\n            pinned.push('bottom');\n          } else {\n            oob.push('bottom');\n          }\n        }\n        if (left < bounds[0]) {\n          if (__indexOf.call(pin, 'left') >= 0) {\n            left = bounds[0];\n            pinned.push('left');\n          } else {\n            oob.push('left');\n          }\n        }\n        if (left + width > bounds[2]) {\n          if (__indexOf.call(pin, 'right') >= 0) {\n            left = bounds[2] - width;\n            pinned.push('right');\n          } else {\n            oob.push('right');\n          }\n        }\n        if (pinned.length) {\n          pinnedClass = (_ref7 = this.options.pinnedClass) != null ? _ref7 : this.getClass('pinned');\n          addClasses.push(pinnedClass);\n          for (_m = 0, _len4 = pinned.length; _m < _len4; _m++) {\n            side = pinned[_m];\n            addClasses.push(\"\" + pinnedClass + \"-\" + side);\n          }\n        }\n        if (oob.length) {\n          oobClass = (_ref8 = this.options.outOfBoundsClass) != null ? _ref8 : this.getClass('out-of-bounds');\n          addClasses.push(oobClass);\n          for (_n = 0, _len5 = oob.length; _n < _len5; _n++) {\n            side = oob[_n];\n            addClasses.push(\"\" + oobClass + \"-\" + side);\n          }\n        }\n        if (__indexOf.call(pinned, 'left') >= 0 || __indexOf.call(pinned, 'right') >= 0) {\n          eAttachment.left = tAttachment.left = false;\n        }\n        if (__indexOf.call(pinned, 'top') >= 0 || __indexOf.call(pinned, 'bottom') >= 0) {\n          eAttachment.top = tAttachment.top = false;\n        }\n        if (tAttachment.top !== targetAttachment.top || tAttachment.left !== targetAttachment.left || eAttachment.top !== this.attachment.top || eAttachment.left !== this.attachment.left) {\n          this.updateAttachClasses(eAttachment, tAttachment);\n        }\n      }\n      defer(function() {\n        updateClasses(_this.target, addClasses, allClasses);\n        return updateClasses(_this.element, addClasses, allClasses);\n      });\n      return {\n        top: top,\n        left: left\n      };\n    }\n  });\n\n}).call(this);\n\n(function() {\n  var defer, getBounds, updateClasses, _ref;\n\n  _ref = this.Tether.Utils, getBounds = _ref.getBounds, updateClasses = _ref.updateClasses, defer = _ref.defer;\n\n  this.Tether.modules.push({\n    position: function(_arg) {\n      var abutted, addClasses, allClasses, bottom, height, left, right, side, sides, targetPos, top, width, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref1, _ref2, _ref3, _ref4, _ref5,\n        _this = this;\n      top = _arg.top, left = _arg.left;\n      _ref1 = this.cache('element-bounds', function() {\n        return getBounds(_this.element);\n      }), height = _ref1.height, width = _ref1.width;\n      targetPos = this.getTargetBounds();\n      bottom = top + height;\n      right = left + width;\n      abutted = [];\n      if (top <= targetPos.bottom && bottom >= targetPos.top) {\n        _ref2 = ['left', 'right'];\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\n          side = _ref2[_i];\n          if ((_ref3 = targetPos[side]) === left || _ref3 === right) {\n            abutted.push(side);\n          }\n        }\n      }\n      if (left <= targetPos.right && right >= targetPos.left) {\n        _ref4 = ['top', 'bottom'];\n        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {\n          side = _ref4[_j];\n          if ((_ref5 = targetPos[side]) === top || _ref5 === bottom) {\n            abutted.push(side);\n          }\n        }\n      }\n      allClasses = [];\n      addClasses = [];\n      sides = ['left', 'top', 'right', 'bottom'];\n      allClasses.push(this.getClass('abutted'));\n      for (_k = 0, _len2 = sides.length; _k < _len2; _k++) {\n        side = sides[_k];\n        allClasses.push(\"\" + (this.getClass('abutted')) + \"-\" + side);\n      }\n      if (abutted.length) {\n        addClasses.push(this.getClass('abutted'));\n      }\n      for (_l = 0, _len3 = abutted.length; _l < _len3; _l++) {\n        side = abutted[_l];\n        addClasses.push(\"\" + (this.getClass('abutted')) + \"-\" + side);\n      }\n      defer(function() {\n        updateClasses(_this.target, addClasses, allClasses);\n        return updateClasses(_this.element, addClasses, allClasses);\n      });\n      return true;\n    }\n  });\n\n}).call(this);\n\n(function() {\n  this.Tether.modules.push({\n    position: function(_arg) {\n      var left, result, shift, shiftLeft, shiftTop, top, _ref;\n      top = _arg.top, left = _arg.left;\n      if (!this.options.shift) {\n        return;\n      }\n      result = function(val) {\n        if (typeof val === 'function') {\n          return val.call(this, {\n            top: top,\n            left: left\n          });\n        } else {\n          return val;\n        }\n      };\n      shift = result(this.options.shift);\n      if (typeof shift === 'string') {\n        shift = shift.split(' ');\n        shift[1] || (shift[1] = shift[0]);\n        shiftTop = shift[0], shiftLeft = shift[1];\n        shiftTop = parseFloat(shiftTop, 10);\n        shiftLeft = parseFloat(shiftLeft, 10);\n      } else {\n        _ref = [shift.top, shift.left], shiftTop = _ref[0], shiftLeft = _ref[1];\n      }\n      top += shiftTop;\n      left += shiftLeft;\n      return {\n        top: top,\n        left: left\n      };\n    }\n  });\n\n}).call(this);\n\nreturn this.Tether;\n\n}));\n\n\n// WEBPACK FOOTER\n// module.id = 1\n// module.readableIdentifier = ./bower_components/tether/tether.js\n//@ sourceURL=webpack-module:///./bower_components/tether/tether.js");

/***/ }
/******/ ])
})
